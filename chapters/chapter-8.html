<DOCTYPE html>
<html>
	<head>
		<title>User Authentication</title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="../style.css">
	</head>

	<body>
		<div id="content">
			<h1>User Authentication</h1>
			
			<section id="overview">
				<h2>Overview</h2>
				<p>
					大多数应用需要知道它们的用户是谁。当用户连接应用时，他们被应用验证，该过程使得应用知道用户的身份。一旦应用知道它们的用户是谁，它可以给相应用户个性化服务。
				</p>
				<p>
					大多数的验证方法要求用户提供一段验证信息，该信息要么是邮件地址或者是用户名，以及一个密码。本章，将完成一个验证系统。
				</p>
			</section> <!-- END of overview -->
				
				
			<section id="authenticationExtensionForFlask">
				<h2>Authentication Extensions for Flask</h2>

				<section id="preview">
					<h3>Preview</h3>
					<p>
						有很多优秀的python验证库，但是没有一个可以完成所有的任务。本章使用的验证方案使用多个库，并为它们能协作工作提供了粘结代码。以下是使用到的库: <br>
						<ul>
							<li>
								Flask-Login: 管理已经登陆的用户的会话(session)信息。
							</li>
							<li>
								Werkzeug: 密码hashing和验证。
							</li>	
							<li>
								itsdangerous: 以密码的方式保护验证令牌的产生和验证。
							</li>
						</ul>
					</p>
					<p>
						除了验证相关的库以外，也使用通常的扩展: <br>
						<ul>
							<li>Flask-Mail: 发送加密过的邮件。</li>
							<li>
								Flask-Bootstrap: html 模版。
							</li>
							<li>
								Flask-WTF: 网页表单。
							</li>
						</ul>
					</p>
				</section><!-- END of sub topic preview -->

				<section id="passwordSecurity">
					<h3>Password Security</h3>
					<p>
						在网站设计中，存储在数据库中的用户信息的安全经常被开发者忽视。如果攻击者攻破了你的服务器并且可以访问你的用户数据库，那么你的用户将暴露在危险中--这种危险比你认为的还要严重。大多数的用户在多个网站使用相同的密码，这是已知的事实，因此即使你没有存储任何敏感的数据，通过访问你数据库上存储的密码，攻击者可以访问你的用户在其他网站上的账户。
					</p>
					<p>
						安全的将用户密码存储在数据库的关键是，不存储密码本身，而是密码的哈希形式。一个密码哈希函数接受一个密码作为输入，向密码添加一个随机组件(salt).然后向它施加多个单向加密转换。该过程的结果是一个新的字符序列，该序列和原密码没有任何相似性，而且现今没有已知的方法将该序列转换成原密码。可以用验证密码哈希来取代验证原密码，这是因为哈希函数具有重复性：给定相同的输入(密码和salt),则结果总是相同的。
					</p>
				</section> <!-- END of sub topic password security -->


				<section id="HashingPasswordsWithWerkzeug">
					<h3>Hashing Password With WerkZeug</h3>

					<p>
						Werkzeug 的security模块实现了安全密码哈希。通过以下两个函数来实现，各自分别用在注册和验证阶段。
						<ul>
							<li>
								<b>generate_password_hash(password, method='pbkd:sha256', salt_length=8)</b><br>
								<code>method</code>和<code>salt_length</code>适用与绝大多数情况。
							</li>
							<li>
								<b>check_password_hash(hash, password)</b><br>
								返回值为True or False
							</li>
						</ul>
					</p>
					<p>
						以下是对User模型的改变，以添加密码哈希功能:<br>
						<pre class="code">
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model):
	#...
	password_hash = db.Column(db.String(128))

	@property
	def password(self):
		raise AttributeError('password is not a readable attribute')
	
	@password.setter
	def password(self, password):
		self.password_hash = generate_password_hash(password)

	def verify_password(self, password):
		return check_password_hash(self.password_hash, password)

						</pre>
					</p>
					<p>
						密码哈希函数通过只读属性password来实现。当这个属性被设置时，setter方法将会调用werkzeug的generate_password_hash()函数， 并且将结果写入password_hash字段里。尝试读取password属性将会返回一个错误，很明显原密码一旦哈希就不能再被二次赋值。
					</p>
					<p>
						check_password_hash()函数返回True意味着被验证的密码是正确的。
					</p>
					<p>
						完成的密码哈希功能可以在shell中测试:<br>
						<pre class="code">
(venv) $ flask shell
>>>> u = User()
>>>> u.password = 'cat'
>>>> u.password
Trackback (most recent call last):
	....
	AttributeError: password is not readable attribute
>>>> u.password_hash
'pbk.....dfd'
>>>> u.verify_password('cat')
True
>>>> u.verify_password('dog')
False
>>>> u2 = User()
>>>> u2.password = 'cat'
>>>> u2.password_hash
'pbk...dff'
						</pre>
					</p>
					<p>
						注意尝试访问一个用户的password属性将返回AttributeError.并且u和u2即使拥有相同的password值，他们的password_hash也仍旧不一样。可以将上述测试添加到tests文件夹中以支持单元测试。以下是添加的单元测试：<br>
						<pre class="code">
# tests/test_user_model.py: password hashing tests

import unittest
from app.models import User

class UserModelTestCase(unittest.TestCase):
	def test_password_setter(self):
		u = User(password = 'cat')
		self.assertTrue(u.password_hash is not None)
	
	def test_no_password_getter(self):
		u = User(password = 'cat')
		with self.assertRaises(AttributeError):
			u.password

	def test_password_verification(self):
		u = User(password = 'cat')
		self.assertTrue(u.verify_password('cat'))
		self.assertFalse(u.verify_password('dog'))

	def test_password_salts_are_random(self):
		u = User(password = 'cat')
		u2 = User(password = 'cat')
		self.assertTrue(u.password_hash != u2.password_hash)
						</pre>
					</p>

					<p>
						可以使用如下命令来运行新单元测试:<br>
						<pre class="code">
flask test
						</pre>
						如果想确定一切都按照既定运行，可以运行单元测试套件来检查。单元测试应该经常测试，以免该密码哈希的功能不会在将来被打破。
					</p>
				</section> <!-- END of sub topic Hashing Passwords with Werkzeug -->	
			</section> <!-- END of authentication extensions for flask -->

			<section id="creatingAnAuthenticationBlueprint">
				<h2>Creating An Authentication Blueprint</h2>

				<p>
					蓝图在第七章引入的，是在将application的创建移动到一个工厂函数后，是一种在全局作用域中定义路由的方式。在本节中，与用户验证子系统相关的路由将被添加到第二个蓝图auth中。对应用程序的不同子系统使用不同的蓝图是保持代码良好组织的好方法。
				</p>
				<p>
					auth蓝图将被相同名字的python包所持有。以下代码是蓝图包的构造器创建了一个蓝图对象，并且view.py中导入路由：<br>
					<pre class="code">
from flask import Blueprint

auth = Blueprint('auth', __name__)

from .import views
					</pre>
				</p>
				<p>
					以下是与auth蓝图相关的路由函数定义:<br>
					<pre class="code">
# app/auth/views.py: authentication blueprint routes and view functions

from flask import render_template
from . import auth

@auth.route('/login')
def login():
	return render_template('auth/login.html')
					</pre>
				</p>

				<p>
					注意这里render_template()函数的模板文件参数，其是存储在auth文件夹下，而auth是在app/templates/文件夹下的，因为flask规定模板文件的路径与应用程序的templates文件夹路径是相关的。通过将auth的模板文件存储在其相应的子文件夹下，这避免了和main蓝图的命名冲突的风险，甚至是和将来要加入进来的新蓝图。
				</p>
				<p>
					注意，蓝图也可以经过配置来拥有自己独立的模板文件夹。当应用程序配置了多个模板文件夹时，render_temlate()函数首先搜索应用程序定义的模板文件夹，其次搜索由蓝图定义的模板文件夹。
				</p>

				<p>
					auth蓝图需要在create_app()工厂函数中安装到应用程序中。以下是代码:<br>
					<pre class="code">
# app/__init__.py: authentication blueprint registration

def create_app(config_name):
	#..

	from .auth import auth as auth_blueprint
	app.register_blueprint(auth_blueprint, url_prefix='/auth')

	return app
					</pre>
				</p>
				<p>
					在蓝图注册中的url_prefix选项是可选的。一旦使用，所有定义在该蓝图下的路由都会以给定url前缀被注册。比如，/login路由将会被注册成/auth/login, 在开发服务器上的完全url是； http://localhost:5000/auth/login
				</p>
			</section> <!-- END of Creating an Authentication Blueprint -->

			<section id="UserAuthenticationWithFlasklogin">
				<h2>User Authentication with Flask-Login</h2>
				<p>
					当用户登陆进应用程序时，他们的验证状态需要被记录到用户回话中，因此当他们在不同页面之间导航时，这些验证信息是共享的。Flask_Login是一个小型但是极度有用的扩展库，它专注于管理用户验证系统中的该特定方面，而应用程序不用去使用一个庞大的用户验证机制。
				</p>

				<section id="PreparingUserModelForLogins">
					<h3>Preparing the User Model for logins</h3>
					<p>
						Flask-Login工作与应用程序自己的User模型紧密相连。为了能和应用程序的User模型一起工作， Flask-Login要求User模型必须实现一些通用的属性和方法。以下是要求元素的图片:<br>
						<img src='.' alt="this is some items that flask-login require User model to contain">
					</p>
					<p>
						这些属性和方法可以直接在模型类中实现，但是处于方便考虑，flask-login提供了一个UserMixin类，该类包含了上述要求的默认实现，其适用于绝大多数情况。以下是更新后的User模型：<br>
						<pre class="code">
# app/models.py: updates to the User model to support user logins

from flask_login import UserMixin

class User(UserMixin, db.Model):
	__tablename__ = 'users'
	id = db.Column(db.Integer, primary_key = True)
	email = db.Column(db.String(64), unique=True, index=True)
	username = db.Column(db.String(64), unique=True, index=True)
	password_hash = db.Column(db.String(128))
	role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
						</pre>
					</p>
					<p>
						注意此时email字段被添加。在该程序中，用户将以其邮箱地址注册， 因为相比用户名，邮箱地址不容易忘记。
					</p>

					<p>
						以下是flask-login在工厂函数中初始化的代码:<br>
						<pre class="code">
# app/__init__.py: Flask-Login initialazation

from flask_login import LoginManager

login_manager = LoginManager()
login_manager.login_view = 'auth.login'

def create_app(config_name):
	#...
	login_manager.init_app(app)
	#...

						</pre>
					</p>
					<p>
						LoginManager对象的login_view属性设置了登陆页面的路由函数名。Flask_login将会将一个试图访问被保护页面的匿名用户重定向到登陆页面。因为该登陆路由是在一个蓝图中定义，所以endpoint名字需要施加特定蓝图名前缀。	
					</p>
					<p>
						最后，flask_login需要应用程序指定一个函数来被调用，当flask_login扩展需要以制定用户标示符来从数据库中加载指定用户时，该函数会被自动调用。以下是自动加载用户数据的函数:<br>
						<pre class="code">
# app/models.py: user loader function

from . import login_manager

@login_manager.user_loader
def load_user(user_id):
	return User.query.get(int(user_id))
						</pre>
					</p>
					<p>
						flask_login使用login_manager.user_loader装饰器来注册函数，该函数会在flask_login需要获取特定以登陆用户的信息时被调用。用户标示符以字符串的形式被传递给函数，因此在函数将它传递给加载用户数据的sqlalchemy query时，其会被转换成integer.该函数的返回值必须是一个用户对象，或者为None，如果用户标示符无效或者发生其他错误。
					</p>
				</section> <!-- END of sub topic Preparing the user model for logins -->
			</section> <!-- END of User Authentication with flask-login -->
		</div> <!-- END of content -->

		<div id="extend">

		</div>
	</body>

</html>
