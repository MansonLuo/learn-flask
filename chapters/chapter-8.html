<DOCTYPE html>
<html>
	<head>
		<title>User Authentication</title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="../style.css">
	</head>

	<body>
		<div id="content">
			<h1>User Authentication</h1>
			
			<section id="overview">
				<h2>Overview</h2>
				<p>
					大多数应用需要知道它们的用户是谁。当用户连接应用时，他们被应用验证，该过程使得应用知道用户的身份。一旦应用知道它们的用户是谁，它可以给相应用户个性化服务。
				</p>
				<p>
					大多数的验证方法要求用户提供一段验证信息，该信息要么是邮件地址或者是用户名，以及一个密码。本章，将完成一个验证系统。
				</p>
			</section> <!-- END of overview -->
				
				
			<section id="authenticationExtensionForFlask">
				<h2>Authentication Extensions for Flask</h2>

				<section id="preview">
					<h3>Preview</h3>
					<p>
						有很多优秀的python验证库，但是没有一个可以完成所有的任务。本章使用的验证方案使用多个库，并为它们能协作工作提供了粘结代码。以下是使用到的库: <br>
						<ul>
							<li>
								Flask-Login: 管理已经登陆的用户的会话(session)信息。
							</li>
							<li>
								Werkzeug: 密码hashing和验证。
							</li>	
							<li>
								itsdangerous: 以密码的方式保护验证令牌的产生和验证。
							</li>
						</ul>
					</p>
					<p>
						除了验证相关的库以外，也使用通常的扩展: <br>
						<ul>
							<li>Flask-Mail: 发送加密过的邮件。</li>
							<li>
								Flask-Bootstrap: html 模版。
							</li>
							<li>
								Flask-WTF: 网页表单。
							</li>
						</ul>
					</p>
				</section><!-- END of sub topic preview -->

				<section id="passwordSecurity">
					<h3>Password Security</h3>
					<p>
						在网站设计中，存储在数据库中的用户信息的安全经常被开发者忽视。如果攻击者攻破了你的服务器并且可以访问你的用户数据库，那么你的用户将暴露在危险中--这种危险比你认为的还要严重。大多数的用户在多个网站使用相同的密码，这是已知的事实，因此即使你没有存储任何敏感的数据，通过访问你数据库上存储的密码，攻击者可以访问你的用户在其他网站上的账户。
					</p>
					<p>
						安全的将用户密码存储在数据库的关键是，不存储密码本身，而是密码的哈希形式。一个密码哈希函数接受一个密码作为输入，向密码添加一个随机组件(salt).然后向它施加多个单向加密转换。该过程的结果是一个新的字符序列，该序列和原密码没有任何相似性，而且现今没有已知的方法将该序列转换成原密码。可以用验证密码哈希来取代验证原密码，这是因为哈希函数具有重复性：给定相同的输入(密码和salt),则结果总是相同的。
					</p>
				</section> <!-- END of sub topic password security -->


				<section id="HashingPasswordsWithWerkzeug">
					<h3>Hashing Password With WerkZeug</h3>

					<p>
						Werkzeug 的security模块实现了安全密码哈希。通过以下两个函数来实现，各自分别用在注册和验证阶段。
						<ul>
							<li>
								<b>generate_password_hash(password, method='pbkd:sha256', salt_length=8)</b><br>
								<code>method</code>和<code>salt_length</code>适用与绝大多数情况。
							</li>
							<li>
								<b>check_password_hash(hash, password)</b><br>
								返回值为True or False
							</li>
						</ul>
					</p>
					<p>
						以下是对User模型的改变，以添加密码哈希功能:<br>
						<pre class="code">
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model):
	#...
	password_hash = db.Column(db.String(128))

	@property
	def password(self):
		raise AttributeError('password is not a readable attribute')
	
	@password.setter
	def password(self, password):
		self.password_hash = generate_password_hash(password)

	def verify_password(self, password):
		return check_password_hash(self.password_hash, password)

						</pre>
					</p>
					<p>
						密码哈希函数通过只读属性password来实现。当这个属性被设置时，setter方法将会调用werkzeug的generate_password_hash()函数， 并且将结果写入password_hash字段里。尝试读取password属性将会返回一个错误，很明显原密码一旦哈希就不能再被二次赋值。
					</p>
					<p>
						check_password_hash()函数返回True意味着被验证的密码是正确的。
					</p>
					<p>
						完成的密码哈希功能可以在shell中测试:<br>
						<pre class="code">
(venv) $ flask shell
>>>> u = User()
>>>> u.password = 'cat'
>>>> u.password
Trackback (most recent call last):
	....
	AttributeError: password is not readable attribute
>>>> u.password_hash
'pbk.....dfd'
>>>> u.verify_password('cat')
True
>>>> u.verify_password('dog')
False
>>>> u2 = User()
>>>> u2.password = 'cat'
>>>> u2.password_hash
'pbk...dff'
						</pre>
					</p>
					<p>
						注意尝试访问一个用户的password属性将返回AttributeError.并且u和u2即使拥有相同的password值，他们的password_hash也仍旧不一样。可以将上述测试添加到tests文件夹中以支持单元测试。以下是添加的单元测试：<br>
						<pre class="code">
# tests/test_user_model.py: password hashing tests

import unittest
from app.models import User

class UserModelTestCase(unittest.TestCase):
	def test_password_setter(self):
		u = User(password = 'cat')
		self.assertTrue(u.password_hash is not None)
	
	def test_no_password_getter(self):
		u = User(password = 'cat')
		with self.assertRaises(AttributeError):
			u.password

	def test_password_verification(self):
		u = User(password = 'cat')
		self.assertTrue(u.verify_password('cat'))
		self.assertFalse(u.verify_password('dog'))

	def test_password_salts_are_random(self):
		u = User(password = 'cat')
		u2 = User(password = 'cat')
		self.assertTrue(u.password_hash != u2.password_hash)
						</pre>
					</p>

					<p>
						可以使用如下命令来运行新单元测试:<br>
						<pre class="code">
flask test
						</pre>
						如果想确定一切都按照既定运行，可以运行单元测试套件来检查。单元测试应该经常测试，以免该密码哈希的功能不会在将来被打破。
					</p>
				</section> <!-- END of sub topic Hashing Passwords with Werkzeug -->	
			</section> <!-- END of authentication extensions for flask -->

			<section id="creatingAnAuthenticationBlueprint">
				<h2>Creating An Authentication Blueprint</h2>

				<p>
					蓝图在第七章引入的，是在将application的创建移动到一个工厂函数后，是一种在全局作用域中定义路由的方式。在本节中，与用户验证子系统相关的路由将被添加到第二个蓝图auth中。对应用程序的不同子系统使用不同的蓝图是保持代码良好组织的好方法。
				</p>
				<p>
					auth蓝图将被相同名字的python包所持有。以下代码是蓝图包的构造器创建了一个蓝图对象，并且view.py中导入路由：<br>
					<pre class="code">
from flask import Blueprint

auth = Blueprint('auth', __name__)

from .import views
					</pre>
				</p>
				<p>
					以下是与auth蓝图相关的路由函数定义:<br>
					<pre class="code">
# app/auth/views.py: authentication blueprint routes and view functions

from flask import render_template
from . import auth

@auth.route('/login')
def login():
	return render_template('auth/login.html')
					</pre>
				</p>

				<p>
					注意这里render_template()函数的模板文件参数，其是存储在auth文件夹下，而auth是在app/templates/文件夹下的，因为flask规定模板文件的路径与应用程序的templates文件夹路径是相关的。通过将auth的模板文件存储在其相应的子文件夹下，这避免了和main蓝图的命名冲突的风险，甚至是和将来要加入进来的新蓝图。
				</p>
				<p>
					注意，蓝图也可以经过配置来拥有自己独立的模板文件夹。当应用程序配置了多个模板文件夹时，render_temlate()函数首先搜索应用程序定义的模板文件夹，其次搜索由蓝图定义的模板文件夹。
				</p>

				<p>
					auth蓝图需要在create_app()工厂函数中安装到应用程序中。以下是代码:<br>
					<pre class="code">
# app/__init__.py: authentication blueprint registration

def create_app(config_name):
	#..

	from .auth import auth as auth_blueprint
	app.register_blueprint(auth_blueprint, url_prefix='/auth')

	return app
					</pre>
				</p>
				<p>
					在蓝图注册中的url_prefix选项是可选的。一旦使用，所有定义在该蓝图下的路由都会以给定url前缀被注册。比如，/login路由将会被注册成/auth/login, 在开发服务器上的完全url是； http://localhost:5000/auth/login
				</p>
			</section> <!-- END of Creating an Authentication Blueprint -->

			<section id="UserAuthenticationWithFlasklogin">
				<h2>User Authentication with Flask-Login</h2>
				<p>
					当用户登陆进应用程序时，他们的验证状态需要被记录到用户回话中，因此当他们在不同页面之间导航时，这些验证信息是共享的。Flask_Login是一个小型但是极度有用的扩展库，它专注于管理用户验证系统中的该特定方面，而应用程序不用去使用一个庞大的用户验证机制。
				</p>

				<section id="PreparingUserModelForLogins">
					<h3>Preparing the User Model for logins</h3>
					<p>
						Flask-Login工作与应用程序自己的User模型紧密相连。为了能和应用程序的User模型一起工作， Flask-Login要求User模型必须实现一些通用的属性和方法。以下是要求元素的图片:<br>
						<img src='.' alt="this is some items that flask-login require User model to contain">
					</p>
					<p>
						这些属性和方法可以直接在模型类中实现，但是处于方便考虑，flask-login提供了一个UserMixin类，该类包含了上述要求的默认实现，其适用于绝大多数情况。以下是更新后的User模型：<br>
						<pre class="code">
# app/models.py: updates to the User model to support user logins

from flask_login import UserMixin

class User(UserMixin, db.Model):
	__tablename__ = 'users'
	id = db.Column(db.Integer, primary_key = True)
	email = db.Column(db.String(64), unique=True, index=True)
	username = db.Column(db.String(64), unique=True, index=True)
	password_hash = db.Column(db.String(128))
	role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
						</pre>
					</p>
					<p>
						注意此时email字段被添加。在该程序中，用户将以其邮箱地址注册， 因为相比用户名，邮箱地址不容易忘记。
					</p>

					<p>
						以下是flask-login在工厂函数中初始化的代码:<br>
						<pre class="code">
# app/__init__.py: Flask-Login initialazation

from flask_login import LoginManager

login_manager = LoginManager()
login_manager.login_view = 'auth.login'

def create_app(config_name):
	#...
	login_manager.init_app(app)
	#...

						</pre>
					</p>
					<p>
						LoginManager对象的login_view属性设置了登陆页面的路由函数名。Flask_login将会将一个试图访问被保护页面的匿名用户重定向到登陆页面。因为该登陆路由是在一个蓝图中定义，所以endpoint名字需要施加特定蓝图名前缀。	
					</p>
					<p>
						最后，flask_login需要应用程序指定一个函数来被调用，当flask_login扩展需要以制定用户标示符来从数据库中加载指定用户时，该函数会被自动调用。以下是自动加载用户数据的函数:<br>
						<pre class="code">
# app/models.py: user loader function

from . import login_manager

@login_manager.user_loader
def load_user(user_id):
	return User.query.get(int(user_id))
						</pre>
					</p>
					<p>
						flask_login使用login_manager.user_loader装饰器来注册函数，该函数会在flask_login需要获取特定以登陆用户的信息时被调用。用户标示符以字符串的形式被传递给函数，因此在函数将它传递给加载用户数据的sqlalchemy query时，其会被转换成integer.该函数的返回值必须是一个用户对象，或者为None，如果用户标示符无效或者发生其他错误。
					</p>
				</section> <!-- END of sub topic Preparing the user model for logins -->

				<section id="ProtectingRoutes">
					<h3>Protecting Routes</h3>
					<p>
						为了保护一个路由，并限定其只能被已通过验证的用户访问，flask_login提供了一个login_required装饰器。以下是其用例:<br>
						<pre class="code">
# usage of login_required decoreator

from flask_login import login_required

@app.route('/secret')
@login_required
def secret():
	return 'Only authenticated users are allowed!'
						</pre>
					</p>

					<p>
						从上述例子中，可以看出装饰器可以被链式调用。当两个以上装饰器被添加到一个函数上时，每一个装饰器除了会影响目标函数以外，还会影响其声明位置之下的所有东西。在本例中，secret()函数将会使用login_requierd装饰器来防止未验证用户访问，然后被login_required影响而产生的结果函数将会在flask中注册成一个route。反转装饰器之间的顺序会造成错误的结果，因为原函数在接收由login_required装饰器制定的属性之前，其会被注册成一个路由函数。
					</p>
					<p>
						多亏了login_required装饰器，一旦该受保护路由被未验证用户访问，flask-login将会中断用户请求，转而将匿名用户重定向到登陆页面。
					</p>
				</section>  <!-- END of sub topic Protecting Routes -->

				<section id="AddingALoggigForm">
					<h3>Adding a Logging Form</h3>
					<p>
						以下是登陆页面的登陆表格:<br>
						<pre class="code">
# app/auth/forms.py : login form

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length, Email

class LoginForm(FlaskForm):
	email = StringField('Email', validators=[DataRequired(), Length(1, 64), Email()])
	password = PasswordField('Password', validators=[DataRequired()])
	remember_me = BooleanField('Keep me logged in')
	submit = SubmitField('Log In')
						</pre>
					</p>
					<p>
						Password类代表&lt;input&gt;元素，其类型是type="password". BooleanField代表一个单选框。
					</p>
					<p>
						email字段使用多个验证器来确保用户不仅输入了数据，而且输入的数据有效合法。当提供多个验证器时，flask_wtf将会以验证器提供的顺序来对其求值，一旦某个验证器失败，那么错误信息将来源于首次失败的验证器中的第一个。
					</p>

					<p>
						和登陆页面相关联的模板文件存储为tempaltes/auth/login.html，一下是登陆页面的图片：
					</p>
					<p>
						在base.html中的导航条使用jinja2条件来显示Log in 或者Log Out链接，其取决于当前用户的登陆状态。以下是模板条件代码：<br>

						<pre class="code">
# app/templates/base.html: Log In and Log Out navigation bar links

&lt;ul class="nav navbar-nav navbar-right"&gt;
	{% if current_user.is_authenticated %}
		&lt;li&gt; &lt;a href="{{ url_for('auth.logout') }}"&gt;Log Out&lt;/a&gt;&lt;/li&gt;
	{% else %}
		&lt;li&gt; &lt;a href="{{ url_for('auth.login') }}"&gt;Log In&lt;/a&gt;&lt;/li&gt;
	{% endif %}
&lt;/ul&gt;
						</pre>
					</p>
					<p>
						在条件中使用的current_user变量由flask_login定义，并且自动对视图函数和模板有效。该变量包含了当前登陆的用户或者一个代理的匿名用户，如果该用户没有登陆的话。一个匿名对象的is_authenticated属性值为False,因此表达式current_user.is_authenticated是一个方便的方法去检测当前用户有没有登陆。
					</p>
				</section> <!-- END of Adding a Logging Form -->

				<section id="SigningUserIn">
					<h3>Signing Users In</h3>
					<p>
						以下是login()视图函数的实现代码:<br>
						<pre class="code">
# app/auth/views.py: login route

from flask import render_template, redirect, request, url_for, flash
from flask_login import login_user
from . import auth
from ..models import User
from .forms import LoginForm

@auth.route('/login', methods=["GET", "POST"])
def login():
	form = LoginForm()
	if form.validate_on_submite():
		user = User.query.filter_by(email=form.email.data).first()
		if user is not None and user.verify_password(form.password.data):
			login_user(user, form.remember.data)
			next = request.args.get('next')
			if next is None or not next.startwith('/'):
				next = url_for('main.index')
			return rediret(next)
		flash('Invalid username or password')
	return render_template('auth/login.html', form=form)
						</pre>
					</p>
					<p>
						该视图函数创建一个LoginForm对象，就像在第四章的简单表格一样使用它。当请求属于GET类型时，该视图函数只是渲染模板，而模板一次显示表格。当表格以POST请求被提交时，flask_wtf的validate_on_submit()函数验证表单变量，然后尝试让用户登陆。
					</p>
					<p>
						为了让用户登陆，该函数先是使用表单提供的email字段来在数据库中尝试加载用户，如果拥有制定email的用户存在，则verify_password()函数将会验证表单提供的password字段。如果密码有效，则flask_login的login_user()函数被调用，用以在用户会话中记录当前用户为以登陆状态。login_user()函数允许用户登陆以及接受一个可选的参数remember_me布尔值。该参数为False时，一旦当前窗体被关闭，那么存储用户登陆状态的用户会话就会过期，因此用户下一次必须重新登陆。而True值造成一个长期的cookie存在与用户的浏览器中，而flask_login使用该cookie来恢复用户会话。可选的REMEMBER_COOKIE_DURATION配置选项可以被用来改变cookie默认的一年时间的存储时长。
					</p>
				</section> <!-- END of Signing User in -->
			</section> <!-- END of User Authentication with flask-login -->
		</div> <!-- END of content -->

		<div id="extend">

		</div>
	</body>

</html>
